你正在当前项目中工作。用户已请求使用参数创建或重新生成文档："$ARGUMENTS"

## 自动加载的项目上下文：
@/CLAUDE.md
@/docs/ai-context/project-structure.md
@/docs/ai-context/docs-overview.md

## 关键：AI 优化的文档原则
所有文档必须针对 AI 消费和未来验证进行优化：
- **结构化和简洁**：使用清晰的部分、列表和层次结构。仅提供必要信息。
- **上下文完整**：包含必要的上下文、决策理由（"为什么"）和交叉引用。
- **模式导向**：使架构模式、约定和数据流显式化。
- **模块化和可扩展**：为部分更新和项目增长而结构化。
- **交叉引用**：用文件路径、函数名和稳定标识符链接相关概念

---

## 步骤 1：分析和策略制定

使用自动加载的项目上下文，分析用户的请求并确定最佳文档策略。

### 1.1. 解析目标和评估复杂性
**操作**：分析 `$ARGUMENTS` 以识别 `target_path` 及其文档层级。

**目标分类：**
- **第3层（功能特定）**：包含 `/src/` 且以 `/CONTEXT.md` 结尾的路径
- **第2层（组件级别）**：以组件根 `/CONTEXT.md` 结尾的路径

**复杂性评估标准：**
- **代码库大小**：目标目录中的文件数和代码行数
- **技术组合**：语言和框架的多样性（Python、TypeScript 等）
- **架构复杂性**：依赖图和跨组件导入
- **现有文档**：该区域任何 CLAUDE.md 文件的存在和状态

### 1.2. 选择策略
基于自动加载的项目上下文，深入思考这个文档生成任务和策略。根据评估，选择并宣布策略。

**策略逻辑：**
- **直接创建**：简单目标（< 15 个文件，单一技术，标准模式）
- **重点分析**：中等复杂性（15-75 个文件，2-3 种技术，一些新颖模式）
- **全面分析**：高复杂性（> 75 个文件，3+ 种技术，显著的架构深度）

---

## 步骤 2：信息收集（分析阶段）

根据选择的策略，收集必要信息。

### 策略 A：直接创建
直接进入**步骤 3.1**。在内容生成期间执行轻量级分析。

### 策略 B：重点或全面分析（子代理编排）

#### 2.1. 子代理角色
根据复杂性评估从这些专业角色中选择：
- **`Code_Analyzer`**：文件结构、实现模式、逻辑流、编码约定
- **`Tech_Stack_Identifier`**：框架、库、依赖关系、技术特定模式
- **`Architecture_Mapper`**：跨组件依赖关系、集成点、数据流
- **`Doc_Validator`**：现有文档准确性、差距、有价值的洞察、内容重叠分析

#### 2.2. 启动子代理
**执行计划：**
- **重点分析（2-3 个代理）**：`Code_Analyzer` + `Tech_Stack_Identifier` + `Doc_Validator`（如果存在现有文档）
- **全面分析（3-4 个代理）**：根据需要使用所有代理

**关键：使用单个消息的多个 Task 工具调用并行启动代理以获得最佳性能。**

**任务模板：**
```
任务："作为 [Agent_Role]，分析 `[target_path]` 的代码库以支持文档生成。

你的重点：[角色特定目标，例如 '识别所有架构模式和依赖关系']

标准工作流：
1. 审查自动加载的项目上下文（CLAUDE.md、project-structure.md、docs-overview.md）
2. 分析你专业领域的目标路径
3. 返回用于文档生成的结构化发现

返回你在此角色中发现的全面摘要。"
```

---

## 步骤 3：文档生成

深入思考综合发现和生成全面文档。使用收集的信息，智能地综合和生成文档内容。

### 3.1. 内容综合和生成

#### 对于直接创建（无子代理）
**代码优先分析方法：**
1. **目录结构分析**：使用 Glob/LS 映射文件组织和用途
2. **导入依赖分析**：使用 Grep 识别集成模式和依赖关系
3. **模式提取**：读取关键文件以识别架构模式和编码约定
4. **技术使用分析**：检测框架、库和技术特定模式
5. **现有文档评估**：读取任何当前的 CLAUDE.md 文件以获得有价值的洞察

#### 对于子代理策略
**综合集成过程：**
1. **编译核心发现**：合并代理发现以立即生成文档
2. **提取跨层模式**：识别可能影响基础文档的系统级模式
3. **解决信息冲突**：当代码与现有文档冲突时，使用代码作为真实来源
4. **识别内容差距**：根据分析找到需要新文档的区域
5. **应用项目约定**：使用来自自动加载的 /CLAUDE.md 的编码标准和命名约定
6. **内容重叠识别**：从 Doc_Validator 发现中，识别与目标内容重叠的现有文档，以便后续迁移分析

#### 内容生成过程
**对于两种方法：**
1. **选择模板**：根据目标分类选择第2层或第3层
2. **应用内容处理策略**：
   - **保留**：来自现有文档的经过验证的架构洞察
   - **增强**：用新发现的实现细节扩展现有模式
   - **替换**：与当前代码现实冲突的过时内容
   - **创建**：未记录模式和决策的新文档
3. **填充部分**：用综合发现填充模板部分
4. **确保完整性**：包括架构决策、模式、依赖关系和集成点
5. **遵循 AI 优化原则**：为 AI 消费提供清晰的交叉引用结构

### 3.2. 模板指导原则

**第2层（组件级别）：**
```markdown
# [组件名称] - 组件上下文

## 目的
[组件目的和关键职责]

## 当前状态：[状态]
[带有演化上下文和理由的状态]

## 组件特定开发指南
[技术特定模式和约定]

## 主要子系统组织
[基于实际代码组织的高级结构]

## 架构模式
[核心模式和设计决策]

## 集成点
[与其他组件的依赖关系和连接]
```

**第3层（功能特定）：**
```markdown
# [功能区域] 文档

## [区域] 架构
[关键架构元素和集成模式]

## 实现模式
[核心模式和错误处理策略]

## 关键文件和结构
[带有用途的文件组织]

## 集成点
[这如何与系统的其他部分集成]

## 开发模式
[测试方法和调试策略]
```

---

## 步骤 4：最终化和整理

### 4.1. 写入文档文件
**操作**：将生成的内容写入目标路径。

### 4.2. 更新文档注册表

#### 更新 docs-overview.md
**对于新文档文件：**
- 添加到适当的层级部分（功能特定或组件级别）
- 遵循已建立的条目格式，包含路径和描述
- 在部分内保持字母顺序

**对于更新的现有文件：**
- 验证条目存在且描述是当前的
- 更新任何更改的目的或范围

#### 更新项目结构（如需要）
**如果创建了新目录：**
- 更新 `/docs/ai-context/project-structure.md` 中的文件树
- 添加解释目的的目录注释
- 保持树结构格式和组织

### 4.3. 质量验证
**操作**：验证层级适当性、代码准确性、交叉引用有效性，以及与现有文档模式的一致性。

### 4.4. 第1层验证和建议

**操作**：将发现的代码模式与基础文档进行比较，以识别不一致性和改进机会。

#### 过程
1. **发现第1层文件**：读取 `/docs/ai-context/docs-overview.md` 以识别所有基础文档文件
2. **读取基础文档**：加载发现的第1层文件以了解记录的架构
3. **跨层分析**：使用前面步骤的分析发现，比较：
   - **技术栈**：发现的框架/工具 vs 记录的栈
   - **架构模式**：实现现实 vs 记录的决策
   - **集成点**：实际依赖关系 vs 记录的集成
4. **生成建议**：输出基于证据的基础文档更新建议

### 4.5. 内容迁移和冗余管理

**操作**：智能管理内容层次结构并消除文档层级间的冗余。

#### 交叉引用分析
1. **识别相关文档**：使用步骤 3.1 综合中的 Doc_Validator 发现和目标层级分类，识别可能包含重叠内容的现有文档
2. **内容重叠检测**：将新文档内容与现有文件比较，以识别：
   - **重复信息**：应只在一个位置存在的相同内容
   - **层次重叠**：存在于错误层级的内容（架构文档中的实现细节）
   - **交叉引用机会**：应链接而非重复的内容

#### 智能内容迁移策略
**内容分类框架：**
- **层级适当的重复**：高级架构上下文可以在第2层和第3层以不同详细级别存在
- **迁移候选**：详细实现模式、特定代码示例、功能特定技术细节
- **引用目标**：稳定的架构决策、设计理由、跨领域关注

**迁移决策逻辑：**
1. **对于第3层创建（功能特定）**：
   - **从第2层提取**：将功能特定实现细节移动到新的第3层文件
   - **在第2层保留**：保持高级架构概述和设计决策
   - **添加交叉引用**：链接第2层概述到详细的第3层实现

2. **对于第2层创建（组件级别）**：
   - **从多个第3层合并**：聚合现有功能文档的架构洞察
   - **保留第3层详细信息**：在功能文档中保持实现特定内容
   - **创建导航结构**：添加到相关第3层文档的引用

#### 内容迁移执行
**迁移过程：**
1. **识别源内容**：提取应从现有文件迁移的内容
2. **内容转换**：将内容适应到适当的层级（架构 vs 实现重点）
3. **更新源文件**：移除已迁移的内容并添加到新位置的交叉引用
4. **保留上下文**：确保源文件在内容移除后保持连贯性
5. **验证迁移**：确认没有断开的引用或丢失的信息

**安全框架：**
- **保守默认**：当不确定时，保留原位置的内容并添加引用
- **内容保存**：在其他地方创建内容之前，绝不删除内容
- **迁移可逆性**：记录所有迁移以便在需要时回滚

---

## 步骤 5：生成摘要

提供全面摘要，包括：

### 文档创建结果
- **文档类型和位置**（第2层或第3层）
- **使用的策略**（直接创建、重点分析或全面分析）
- **记录的关键模式**（架构决策、实现模式）
- **进行的注册表更新**（docs-overview.md、project-structure.md 条目）

### 第1层架构智能
**基于步骤 4.4 分析，提供结构化建议：**

#### 需要的关键更新
- **文件**：[特定基础文档路径]
- **问题**：[有证据的特定不一致性]
- **建议**：[需要的特定更新]
- **证据**：[支持建议的代码引用]

#### 架构增强机会
- **识别的差距**：[缺失的基础文档区域]
- **范围**：[应记录什么]
- **理由**：[为什么这值得基础文档]
- **实现证据**：[发现的代码模式]

#### 文档健康评估
- **对齐分数**：[代码和文档间的整体一致性]
- **最准确区域**：[与实现匹配良好的基础文档]
- **需要关注的区域**：[有显著差距/不一致性的基础文档]
- **系统改进优先级**：[解决问题的推荐顺序]

#### 内容迁移结果
**记录所有内容层次变更和冗余消除：**

- **内容迁移自**：[源文件路径] → [目标文件路径]
  - **内容类型**：[例如 "实现模式"、"技术细节"、"架构决策"]
  - **理由**：[为什么这个内容属于目标层级]
  - **添加的交叉引用**：[层级间创建的导航链接]

- **内容保留在**：[更广泛的层级文件]
  - **内容类型**：[例如 "架构概述"、"设计决策"、"集成模式"]
  - **理由**：[为什么这个内容保留在更广泛的层级]

- **消除的冗余**：
  - **移除的重复内容**：[消除的特定重复]
  - **层次纠正**：[移动到适当层级的内容]
  - **引用合并**：[链接替换重复的区域]

- **迁移安全性**：
  - **内容保存**：[确认没有信息丢失]
  - **回滚信息**：[可能逆转的更改文档]
  - **验证结果**：[确认没有断开的引用]

#### 下一步文档步骤（可选建议）
- **功能特定文档候选**：[建议有价值的额外第3层文档]
- **跨组件文档需求**：[识别需要类似分析的其他组件]
- **消除的文档债务**：[解决的冗余和不一致性摘要]

---

现在根据请求继续创建/重新生成文档：$ARGUMENTS