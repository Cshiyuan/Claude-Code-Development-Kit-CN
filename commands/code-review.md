# /code-review

*执行聚焦的多代理代码审查，为使用 AI 工具的独立开发者提供仅关键的高影响发现。*

## 核心理念

此命令优先考虑**真正有价值的发现**而不是详尽的清单。每个发现都必须在以下方面展现重大影响：
- 系统可靠性和稳定性
- 具有真实利用风险的安全漏洞
- 影响用户体验的性能瓶颈
- 阻碍未来扩展性的架构决策
- 威胁可维护性的关键技术债务

### 🚨 仅关键发现
可能在 48 小时内导致生产故障、安全漏洞或严重用户影响的问题。

### 🔥 高价值改进
解锁新功能、移除重大约束或将指标改善 >25% 的变更。

### ❌ 报告排除项
次要风格问题、微优化（<10%）、理论最佳实践、影响 <1% 用户的边缘情况。


## 自动加载的项目上下文：
@/CLAUDE.md
@/docs/ai-context/project-structure.md
@/docs/ai-context/docs-overview.md


## 命令执行

用户提供的上下文：\"$ARGUMENTS\"

### 步骤 1：理解用户意图并收集上下文

#### 解析请求
分析自然语言输入以确定：
1. **审查什么**：解析文件路径、组件名称、功能描述或提交引用
2. **审查重点**：识别提及的任何特定关注点（安全、性能等）
3. **范围推断**：智能确定所需的审查广度

意图解析示例：
- "authentication flow" → 查找代码库中与认证相关的所有文件
- "voice pipeline implementation" → 定位语音处理组件
- "recent changes" → 解析 git 历史查找相关提交
- "the API routes" → 识别所有 API 端点文件

#### 阅读相关文档
在分配代理之前，**阅读文档**以理解：
1. 使用 `/docs/ai-context/docs-overview.md` 识别相关文档
2. 阅读与被审查代码相关的文档：
   - 子系统理解的架构文档
   - 集成点的 API 文档
   - 敏感区域的安全指南
   - 关键路径的性能考虑
3. 构建风险、约束和优先级的心智模型

此上下文确保基于实际项目知识进行智能代理分配。

### 步骤 2：定义强制覆盖区域

每次代码审查都必须分析这些核心区域，深度由范围决定：

#### 🎯 强制覆盖区域：

1. **关键路径分析**
   - 可能出现故障的面向用户功能
   - 数据完整性和状态管理
   - 错误处理和恢复机制

2. **安全表面**
   - 输入验证和清理
   - 认证/授权流程
   - 数据暴露和 API 安全

3. **性能影响**
   - 实时处理瓶颈
   - 资源消耗（内存、CPU）
   - 可扩展性约束

4. **集成点**
   - API 合约和边界
   - 服务依赖
   - 外部系统交互

#### 📊 动态代理分配：

根据审查范围，按比例分配代理：

**小到中等范围（小文件集或小功能）**
- 2-3 个代理覆盖强制区域
- 每个代理处理 1-2 个覆盖区域
- 专注于最高风险方面

**大范围（多个文件、主要功能或子系统）**
- 4-6 个具有专业化焦点的代理
- 每个强制区域获得专门覆盖
- 为跨领域关注点增加额外代理

### 步骤 3：动态代理生成

基于范围分析和强制覆盖区域，动态创建专业化代理：

#### 代理生成策略：

**运用你从步骤 1 获得的文档知识，深入思考**最优代理分配：
- 利用你对项目架构和风险的理解
- 考虑你阅读的关于此子系统的特定文档
- 应用关于关键路径和安全考虑的洞察
- 使用文档化的边界和集成点来划分工作
- 考虑文档中的任何性能或可扩展性问题

使用你对项目的理解来直觉地确定：
1. **需要多少代理** - 让代码的复杂性和关键性指导你
2. **如何划分工作** - 遵循自然的架构边界
3. **哪些专业化最重要** - 在风险最高的地方集中代理

**生成专业化代理**

   为每个分配的代理创建一个聚焦角色：

   **6 代理分配示例：**
   - 代理 1：Critical_Path_Validator（用户流程 + 错误处理）
   - 代理 2：Security_Scanner（输入验证 + 认证）
   - 代理 3：API_Security_Auditor（数据暴露 + 边界）
   - 代理 4：Performance_Profiler（瓶颈 + 资源使用）
   - 代理 5：Scalability_Analyst（约束 + 增长路径）
   - 代理 6：Integration_Verifier（依赖 + 合约）

   **3 代理分配示例：**
   - 代理 1：Security_Performance_Analyst（安全 + 性能区域）
   - 代理 2：Critical_Path_Guardian（功能 + 集成）
   - 代理 3：Risk_Quality_Assessor（技术债务 + 代码质量）

#### 动态焦点区域：

每个代理根据以下接收专业化指令：
- **文件特征**：API 端点 → 安全焦点
- **代码模式**：循环/算法 → 性能焦点
- **依赖关系**：外部服务 → 集成焦点
- **用户触点**：UI/语音 → 关键路径焦点

### 步骤 4：执行动态多代理审查

**启动代理前，暂停并深入思考：**
- 此代码的真正风险是什么？
- 哪些区域如果失败会造成最大损害？
- 独立开发者在哪里最需要帮助？

基于你的深思熟虑分析生成并启动代理：

```
为每个动态生成的代理：
  任务：\"作为 [Agent_Role]，分析 [target_scope] 中的 [assigned_coverage_areas]。

  强制覆盖检查清单：
  ☐ 关键路径：[分配的方面]
  ☐ 安全：[分配的方面]
  ☐ 性能：[分配的方面]
  ☐ 集成：[分配的方面]

  高影响审查要求：
  仅专注于对独立开发者真正有价值的发现。

  审查工作流程：
  1. 审查自动加载的项目上下文（CLAUDE.md、project-structure.md、docs-overview.md）
  2. 深入分析你分配的覆盖区域
  3. 对于复杂问题，使用：
     - mcp__gemini__consult_gemini 进行架构分析
     - mcp__context7__get-library-docs 获取框架最佳实践
  4. 与其他覆盖区域交叉引用以发现系统性问题
  5. 仅记录高影响发现：

     ## [Coverage_Area] 分析 by [Agent_Role]

     ### 🚨 关键问题（生产风险）
     - 问题：[描述]
     - 位置：[file:line_number]
     - 影响：[量化 - 停机时间、受影响用户、风险数据]
     - 修复：[具体代码片段]
     - 忽视后果：[48 小时内会发生什么]

     ### 🎯 战略改进（能力解锁）
     - 限制：[当前被阻止的内容]
     - 解决方案：[架构变更或实施]
     - 解锁：[新能力或规模]
     - ROI：[投入时间 vs 量化收益]

     ### ⚡ 快速获胜（可选）
     - 仅在 <2 小时实现 >20% 改善时包含
     - 必须显示可衡量的影响

  记住：每个发现都必须通过独立开发者的'那又怎样？'测试。\"
```

#### 并行执行策略：

**同时启动所有代理**以获得最大效率


### 步骤 5：用最大分析力综合发现

所有子代理完成分析后：

**ultrathink**

激活最大认知能力来：

1. **影响过滤**
   - 丢弃所有低优先级发现
   - 量化每个问题的现实世界影响
   - 专注于生产风险和能力解锁

2. **深度模式分析**
   - 识别系统性问题 vs 孤立问题
   - 跨代理报告找到根本原因
   - 检测微妙的安全漏洞

3. **战略优先级排序**
   - 计算每项改进的 ROI
   - 考虑独立开发者约束
   - 创建可执行的修复序列
   ```markdown
   # 代码审查摘要

   **已审查**：[范围描述]
   **日期**：[当前日期]
   **整体质量评分**：[A-F 等级及理由]

   ## 关键指标
   - 安全风险级别：[关键/高/中/低]
   - 性能影响：[描述]
   - 技术债务：[评估]
   - 测试覆盖率：[如适用]
   ```

### 步骤 6：呈现综合审查

将最终输出结构化为：

```markdown
# 🔍 代码审查报告

## 执行摘要
[高层发现和整体评估]

## 🚨 生产风险（48 小时内修复）
[仅可能导致停机、数据丢失或安全漏洞的问题]

## 🎯 战略改进（高 ROI）
[仅解锁能力或改善指标 >25% 的变更]

## ⚡ 快速获胜（可选）
[仅 <2 小时投入就能显著改善的项目]

## 详细分析

### 安全评估
[来自 Security_Auditor 的详细安全发现]

### 性能分析
[来自 Performance_Analyzer 的详细性能发现]

### 架构审查
[来自 Architecture_Validator 的详细架构发现]

### 代码质量评估
[来自 Quality_Inspector 的详细质量发现]

[基于所使用子代理的其他部分]

## 行动计划
1. 防止生产故障的关键修复
2. 解锁能力的高 ROI 改进

## 影响矩阵
| 问题 | 用户影响 | 投入 | ROI |
|-------|-------------|--------|-----|
| [仅具有量化指标的高影响问题] |
```

### 步骤 7：交互式后续

呈现审查后，提供交互式后续选项。例如：
- \"你希望我修复任何关键问题吗？\"
- \"我应该为任何组件创建详细的重构计划吗？\"
- \"你想让我为未覆盖的代码生成测试吗？\"
- \"我应该创建 GitHub issues 来跟踪这些改进吗？\"

## 实施注意事项

1. **使用并行 Task 执行**对所有子代理以最小化审查时间
2. **包含 file:line_number 引用**便于导航
3. **平衡批评与认可**好的实践
4. **提供可执行的修复**，不仅仅是问题识别
5. **考虑项目阶段**和优先级，推荐变更时
6. **在有益时使用 MCP 服务器**进行专业化分析
7. **保持安全发现敏感**- 不要公开暴露漏洞

## 错误处理

### 覆盖验证

呈现结果前，验证完整覆盖：

```
☑ 关键路径分析：[由代理 X、Y 覆盖]
☑ 安全表面：[由代理 Y、Z 覆盖]
☑ 性能影响：[由代理 X、Z 覆盖]
☑ 集成点：[由代理 W、X 覆盖]
```

如果任何区域缺乏覆盖，部署额外的聚焦代理。

## 错误处理

如果审查过程中出现问题：
- **模糊输入**：使用搜索工具查找相关文件，然后再要求澄清
- **找不到文件**：搜索整个代码库中的类似名称或组件
- **检测到大范围**：基于计算的复杂性动态扩展代理
- **未找到文件**：基于项目结构提供有用建议
- **覆盖空白**：为遗漏区域部署补充代理