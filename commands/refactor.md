您正在当前项目上工作。用户要求重构在其参数中用 @ 符号标记的特定文件："$ARGUMENTS"

## 自动加载的项目上下文：
@/CLAUDE.md
@/docs/ai-context/project-structure.md
@/docs/ai-context/docs-overview.md

## 步骤 1：解析标记文件
从用户参数中提取所有带 @ 标记的文件路径。仅处理明确带有 @ 符号标记的文件。

**解析示例：**
- 输入："refactor @src/big-file.ts @components/Large.svelte"
- 提取：["src/big-file.ts", "components/Large.svelte"]

## 步骤 2：验证和分析文件
对于每个标记的文件：
1. **验证文件存在** - 如果文件不存在，通知用户并跳过
2. **读取文件内容** - 理解结构和依赖关系
3. **分析当前目录结构** - 映射文件周围的现有模式

## 步骤 3：智能分析策略决策
基于自动加载的项目上下文，深入思考最安全和最有效的重构方法。基于步骤 2 的初始分析和自动加载的项目上下文，智能决定每个文件的最佳方法：

### 策略选项：

**直接重构**（0-1 个子代理）：
- 具有清晰、明显拆分点的简单文件
- 外部依赖关系最少的文件
- 标准重构模式（例如，提取工具函数，拆分大类）
- 破坏性变更风险低

**专注分析**（2-3 个子代理）：
- 具有特定关注点的中等复杂度
- 具有中等依赖足迹的文件
- 当一个方面需要深度分析时（例如，复杂依赖关系或复杂文件结构）

**全面分析**（3 个或更多子代理）：
- 具有多个关注点的高复杂度文件
- 广泛的依赖网络
- 项目中未见过的新颖重构模式
- 破坏性变更的高风险
- 对多个系统至关重要的文件

## 步骤 4：执行选定策略

### 对于直接重构：
使用初始分析和项目上下文进行直接重构。

### 对于子代理方法：
您拥有完全自主权，可以根据识别的特定重构需求设计和启动子代理。考虑这些关键调查领域，并设计自定义代理来覆盖最相关的内容：

**要考虑的核心调查领域：**
- **文件结构分析**：逻辑组件边界、拆分点、内聚性评估
- **依赖网络映射**：导入/导出分析、使用模式、循环依赖风险
- **项目模式合规性**：目录结构、命名约定、组织模式
- **影响评估**：需要更新的测试文件、配置文件、构建脚本
- **导入更新分析**：所有从目标文件导入并需要更新导入路径的文件
- **技术栈考虑**：特定语言模式、框架约定

**自主子代理设计原则：**
- **自定义专业化**：基于特定文件的复杂性和风险定义代理
- **灵活的代理数量**：根据需要使用尽可能多的代理 - 根据实际复杂性扩展
- **自适应覆盖**：确保关键方面得到覆盖，避免不必要的重叠
- **风险导向分析**：优先调查最高风险的重构方面

**子代理任务模板：**
```
任务："分析 [SPECIFIC_INVESTIGATION_AREA] 以安全重构与用户请求 '$ARGUMENTS' 相关的 [TARGET_FILE]"

标准调查工作流：
1. 审查自动加载的项目上下文（CLAUDE.md、project-structure.md、docs-overview.md）
2. [CUSTOM_ANALYSIS_STEPS] - 彻底调查特定领域
3. 返回支持安全有效重构的可行性发现

返回针对此调查领域的全面发现。"
```

**关键：启动子代理时，始终使用包含多个 Task 工具调用的单一消息进行并行执行。**


## 步骤 5：综合分析和计划重构

深入思考整合所有子代理调查发现以进行安全有效的重构。结合所有代理的发现来创建最佳重构策略：

### 整合分析
- **文件结构**：使用文件分析代理的组件分解
- **组织**：应用模式识别代理的目录建议
- **安全性**：实施依赖分析代理的导入/导出策略
- **完整性**：处理影响评估代理的更广泛关注点

### 重构策略决策
基于综合分析，确定：
- **拆分粒度**：多少个文件以及什么逻辑划分
- **目录结构**：同级、子目录或现有目录放置
- **导入/导出策略**：如何重构导出并更新所有消费文件
- **文件命名**：遵循项目约定和清晰性

### 风险评估
- **破坏性变更**：识别并减轻潜在问题
- **依赖冲突**：计划导入/导出重构
- **测试影响**：计划测试文件更新
- **文档需求**：识别需要的文档更新

## 步骤 6：重构价值评估

### 评估重构价值
在综合所有分析后，批判性地评估提议的重构是否真正改善代码库：

**积极指标（值得重构）：**
- 文件明显超过合理大小限制（组件 500+ 行，工具函数 1000+ 行）
- 明显违反关注点分离（UI 与业务逻辑混合，多个不相关功能）
- 高圈复杂度可以通过模块化降低
- 可以抽象的重复代码模式
- 通过模块化可以改善的可测试性差
- 依赖关系变得更清洁和可维护
- 与项目架构模式对齐

**消极指标（不值得重构）：**
- 文件尽管大小但已经组织良好
- 拆分会创建人为边界，降低清晰度
- 会引入不必要的复杂性或抽象
- 依赖关系会变得更加复杂
- 文件有效地服务于单一、内聚的目的
- 重构会违反项目约定
- 可维护性的实际改善最小

### 决策点
基于评估：

**如果重构值得：**
- 打印清晰的好处摘要："✅ 此重构将通过以下方式改善代码库：[具体好处]"
- 自动进入步骤 7（执行重构）

**如果重构不值得：**
- 对原因坦诚："❌ 不建议此重构，因为：[具体原因]"
- 解释当前结构的可接受性
- 明确询问用户："文件目前对其目的而言结构良好。您仍然要继续重构吗？（是/否）"
- 仅在用户确认时继续

## 步骤 7：执行重构

基于综合分析实施重构：

### 文件创建顺序
1. **创建目录** - 创建需要的任何新子目录
2. **创建核心文件** - 从主/索引文件开始
3. **创建支持文件** - 类型、工具函数、常量
4. **更新导入** - 修复所有导入/导出语句
5. **更新原始文件** - 替换为新的模块化结构

### 导入/导出管理
- **更新所有消费文件** - 修改导入语句指向新文件位置
- **重构导出** - 在新文件结构中组织导出
- **更新相对导入** - 修复整个代码库的路径
- **遵循命名约定** - 使用项目的既定模式

### 质量保证
- **保持功能性** - 确保无破坏性变更
- **维护类型安全** - 保持所有 TypeScript 类型完整
- **遵循编码标准** - 应用项目的样式指南
- **测试兼容性** - 验证导入正确工作


## 步骤 8：质量验证

对于每个重构的文件：
- **检查导入** - 验证所有导入正确解析
- **运行类型检查** - 确保 TypeScript 编译通过
- **测试功能** - 确认无破坏性变更
- **验证结构** - 确保新组织遵循项目模式


## 错误处理
- **文件未找到** - 跳过并通知用户
- **不值得重构** - 跳过表现良好的文件，并向用户说明
- **解析错误** - 报告语法问题并跳过
- **导入冲突** - 解决或报告问题

## 摘要格式
提供以下全面摘要：
- **分析结果**：每个子代理的关键发现
- **重构策略**：选择的方法和理由
- **价值评估**：重构是否改善代码（来自步骤 6）
- **创建的文件**：新结构及说明（如果进行了重构）
- **修复的依赖关系**：进行的导入/导出变更（如果进行了重构）
- **遇到的问题**：任何问题和解决方案

现在继续对标记文件进行多代理分析和重构：$ARGUMENTS