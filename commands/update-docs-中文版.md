您刚刚完成了当前项目的工作。基于提供的上下文分析变更并自动更新相关文档。

## 自动加载的项目上下文：
@/CLAUDE.md
@/docs/ai-context/project-structure.md
@/docs/ai-context/docs-overview.md

## 核心文档原则：仅记录当前状态

**关键：始终记录系统的当前"是"状态。永远不要引用遗留实现、描述所做的改进或解释什么发生了变化。文档应该看起来就像当前实现始终存在一样。**

### 要避免的文档反模式：
- ❌ "重构了语音管道以使用流式处理而不是批处理"
- ❌ "通过实施缓存改善了性能"
- ❌ "以前使用 X，现在使用 Y 以获得更好的结果"
- ❌ "遗留实现已被替换为..."

### 文档最佳实践：
- ✅ "语音管道使用流式处理进行实时处理"
- ✅ "为频繁访问的数据实施缓存"
- ✅ "使用 Y 以获得最佳结果"
- ✅ "系统架构遵循..."

## 步骤 1：基于输入分析变更

### 确定分析模式：
- **无输入（默认）**：分析最近的对话上下文
- **Git 提交 ID**（例如，"3b8d24e" 或完整哈希）：分析特定提交
- **"uncommitted"/"staged"/"working"**：分析未提交的变更
- **"最近 N 次提交"**（例如，"最近 3 次提交"）：分析最近的提交

### 执行分析：
基于输入参数：

#### 对于 Git 提交分析：
```bash
# 获取提交详情
git show --name-status [COMMIT_ID]
git diff [COMMIT_ID]^ [COMMIT_ID]
```

#### 对于未提交变更：
```bash
# 获取暂存和未暂存的变更
git status --porcelain
git diff HEAD
git diff --cached
```

#### 对于最近提交：
```bash
# 获取最近的提交历史
git log --oneline -n [N]
git diff HEAD~[N] HEAD
```

#### 对于会话上下文（默认）：
检查您最近的对话和工具使用情况中的重大变更。

**寻找与文档相关变更的证据：**
- **新功能或组件**（需要记录的功能）
- **架构决策**（新模式、结构变更、设计决策）
- **技术栈变更**（新依赖关系、框架添加、集成变更）
- **API 变更**（新端点、修改的接口、破坏性变更）
- **配置变更**（新环境变量、设置、部署要求）
- **文件结构变更**（新目录、移动的组件、重组的代码）

**从文档更新中排除：**
- 没有架构影响的性能优化
- 不改变接口或模式的错误修复
- 代码清理、不影响使用的重构
- 日志改进、调试增强
- 没有新功能的测试添加

**生成简要摘要**所完成的工作：
```
分析来源：[会话上下文/提交 ID/未提交变更]
检测到的变更：[主要完成工作的 1-2 句摘要]
```

## 步骤 2：理解项目上下文和文档结构

分析自动加载的基础文件：
1. `/CLAUDE.md` - **关键：**理解管理项目的 AI 指令、编码标准和开发协议
2. `/docs/ai-context/project-structure.md` - **基础：**技术栈、完整文件树和架构概述
3. `/docs/ai-context/docs-overview.md` - 理解：
   - 存在哪些文档文件及其目的
   - 文档是如何组织的
   - 哪些类型的变更映射到哪些文档

**AI 优先文档原则**：记住文档主要供 AI 消费 - 优化文件路径引用、清晰的结构标记和机器可读模式，以实现高效的上下文加载。

## 步骤 3：智能更新策略决策

基于自动加载的项目上下文和检测到的变更，深入思考所需的文档更新。基于步骤 1 中检测到的变更和自动加载的项目上下文，智能决定最佳方法：

### 策略选项：

**直接更新**（0-1 个子代理）：
- 具有清晰文档映射的简单文件修改
- 不影响架构的错误修复或小增强
- 仅限于单个组件或功能区域的变更
- 项目中已充分记录的标准模式

**专注分析**（2-3 个子代理）：
- 影响多个文件的中等复杂度变更
- 引入新颖模式的新功能
- 跨越 2-3 个组件或文档层级的变更
- 需要跨文档验证的技术栈更新

**全面分析**（3 个或更多子代理）：
- 影响多个系统区域的复杂架构变更
- 重构组件关系结构的主要重构
- 创建跨系统依赖关系的新集成
- 需要广泛文档级联更新的变更

## 步骤 4：执行选定策略

### 对于直接更新：
使用检测到的变更和自动加载的基础上下文进行直接文档更新。继续步骤 5（最终决策）。

### 对于子代理方法：
您拥有完全自主权，可以根据检测到的特定变更设计子代理。考虑这些调查领域，并设计自定义代理来覆盖最相关的内容：

**要考虑的核心调查领域：**
- **变更影响分析**：将文件修改映射到所有层级的受影响文档
- **架构验证**：验证现有架构文档是否仍反映当前实现
- **跨组件依赖映射**：识别由于集成变更需要文档更新
- **文档准确性评估**：根据修改的代码模式验证当前文档
- **层级级联要求**：根据变更范围确定哪些文档级别需要更新
- **技术栈验证**：确保技术栈变更在相关文档中得到反映

**自主子代理设计原则：**
- **自定义专业化**：基于特定变更复杂性和文档影响定义代理
- **灵活的代理数量**：根据需要使用尽可能多的代理 - 根据实际变更范围扩展
- **自适应覆盖**：确保所有受影响的文档区域得到覆盖，避免不必要的重叠
- **更新导向分析**：优先调查直接支持准确文档更新的内容

**子代理任务模板：**
```
任务："基于来自 [SOURCE] 的变更分析文档更新的 [SPECIFIC_INVESTIGATION_AREA]：[DETECTED_CHANGES]"

标准调查工作流：
1. 审查自动加载的项目上下文（CLAUDE.md、project-structure.md、docs-overview.md）
2. [CUSTOM_ANALYSIS_STEPS] - 彻底调查特定领域
3. 返回识别所需文档更新的可行性发现

返回针对文档更新此调查领域的全面发现。
```

**关键：使用子代理时，始终使用包含多个 Task 工具调用的单一消息并行启动它们。**

## 步骤 5：综合分析和计划更新

### 对于子代理方法：
深入思考整合所有子代理调查发现以进行最佳文档更新。结合所有代理的发现来创建最佳文档更新策略：

**整合分析：**
- **变更影响**：使用变更影响代理对修改到文档的映射
- **架构验证**：应用架构验证代理对过时信息的发现
- **依赖更新**：实施跨组件代理的集成变更要求
- **准确性纠正**：处理文档准确性代理识别的不一致性
- **级联计划**：执行层级级联代理的多级更新要求

**更新策略决策：**
基于综合分析，确定：
- **文档范围**：哪些文件需要更新以及详细程度
- **更新优先级**：关键架构变更与次要模式更新
- **级联要求**：哪些层级需要协调更新
- **新文件创建**：是否需要新的文档文件

## 步骤 6：最终决策

基于您的上下文分析和自动加载的文档结构（直接或从子代理综合），决定：
- **哪些文档需要更新**（将变更匹配到适当的文档）
- **什么类型的更新**（组件变更、架构决策、新模式等）
- **更新范围**（主要变更获得更多细节，次要变更获得简要更新）
- **是否需要新的文档文件**（见下面的智能文件创建指南）

## 步骤 7：智能文件创建（如果需要）

在更新现有文档之前，评估是否应该基于 3 层系统创建新的文档文件：

### 创建新文档文件的指南

**在以下情况创建新的组件 CONTEXT.md：**
- 您检测到一个全新的顶级组件（`agents/`、`unity-client/`、`supabase-functions/` 等下的新目录）
- 组件具有重要功能（5+ 有意义的文件）
- 示例：添加 `agents/lesson-generator/` → 创建 `agents/lesson-generator/CONTEXT.md`

**在以下情况创建新的功能特定 CONTEXT.md：**
- 您检测到现有组件内的新复杂子系统
- 子系统有 3+ 个文件并代表不同的功能区域
- 没有现有的细粒度 CONTEXT.md 文件覆盖此区域
- 示例：添加具有多个文件的 `agents/tutor-server/src/features/translation/` → 创建 `agents/tutor-server/src/features/CONTEXT.md`

**何时不创建新文件：**
- 适合现有文档范围的小添加（1-2 个文件）
- 错误修复或次要修改
- 临时或实验性代码

**文件创建过程：**
1. **创建新的 CONTEXT.md 文件**，包含遵循现有细粒度文档模式的占位符内容
2. **更新 `/docs/ai-context/docs-overview.md`** 以在适当层级包含新文件
3. **在当前更新过程中记录添加**

### 新细粒度 CONTEXT.md 的文件内容模板：
```markdown
# [功能区域] 文档

*此文件记录 [组件] 内 [特定区域] 的模式和实现。*

## [区域] 架构
- [关键架构元素]

## 实现模式
- [使用的关键模式]

## 集成点
- [这如何与其他部分集成]

---

*此文件作为 3 层文档系统的一部分创建，用于记录 [简要原因]。*
```

## 步骤 8：层级优先文档更新

**关键：始终从第 3 层（功能特定）文档开始，向上级联。永远不要跳过层级。**

### 第 3 层（功能特定）- 从这里开始
**始终从最接近您变更的最细粒度文档开始：**
- **识别受影响的第 3 层文件**（子目录中的功能特定 CONTEXT.md 文件）
- **首先更新这些细粒度文件**，包含具体的实现细节、模式和集成点
- **示例**：`agents/tutor-server/src/core/pipelines/CONTEXT.md`、`web-dashboard/src/lib/api/CONTEXT.md`、`agents/tutor-server/src/features/*/CONTEXT.md`
- **更新指南**：具体说明文件名、技术、实现模式

### 第 2 层（组件级）- 向上级联
**完成第 3 层更新后，评估是否需要组件级变更：**
- **检查父组件 CONTEXT.md 文件**（例如，`agents/tutor-server/src/*/` 中变更的 `agents/tutor-server/CONTEXT.md`）
- **如果变更代表影响整体组件的重大架构转变则更新**
- **专注于**：细粒度变更如何影响组件架构、新集成模式、主要功能添加
- **示例**：`agents/tutor-server/CONTEXT.md`、`web-dashboard/CONTEXT.md`、`unity-client/CONTEXT.md`

### 第 1 层（基础）- 向上级联
**最后，检查系统范围影响的基础文档是否需要更新：**

#### 项目结构更新（`/docs/ai-context/project-structure.md`）
对以下任何变更进行更新：
- **文件树变更**：创建、移动、删除的文件/目录；重命名的组件；重构的组织
- **技术栈更新**：新依赖关系（检查 pyproject.toml、package.json）、主要版本更新、新框架、AI 服务变更、开发工具修改

#### 其他基础文档
如果变更影响以下内容，更新其他 `/docs/ai-context/` 文件：
- **系统范围的架构模式**
- **跨组件集成方法**
- **开发工作流或标准**

### 级联决策逻辑
**什么构成需要级联的"重大更新"：**
- **新的主要功能区域**（不仅仅是错误修复或小增强）
- **影响组件如何与其他组件集成的架构模式变更**
- **引入组件的新技术或框架**
- **改变组件结构或职责的主要重构**
- **组件或外部系统间的新集成点**

### 更新质量指南（所有层级）
- **简洁**（除非是主要架构变更，否则最多 3 句话）
- **具体**（包括文件名、技术、关键好处）
- **遵循现有模式**在每个文档中
- **避免冗余**（不要重复已记录的内容）
- **就近放置知识**（将文档保持在相关代码附近）

## 步骤 9：更新文档概述

**重要：**在步骤 1-8 中更新任何文档文件后，检查文档概述是否需要更新：
- 参考自动加载的 `/docs/ai-context/docs-overview.md`
- 如果您添加了新的文档文件（特别是新的 CONTEXT.md 文件），更新概述以在适当层级包含它们
- 如果您显著改变了现有文档的结构/目的，更新概述以反映这些变更
- 保持概述准确和最新，以便它作为文档架构的可靠指南

### 新 CONTEXT.md 文件的特别说明：
当您创建新的细粒度 CONTEXT.md 文件时，您必须将它们添加到 docs-overview.md 中的适当部分：
- **第 2 层（组件级）**：对于新的顶级组件
- **第 3 层（功能特定）**：对于现有组件内的新子系统文档

## 质量指南

- **简洁：**保持更新简要而专注
- **具体：**包括文件名、技术、关键好处
- **准确：**基于实际所做的变更，而非假设
- **有用：**对另一个开发者有用的信息
- **当前：**确保文件树反映实际项目结构
- **有组织：**遵循 3 层文档系统原则

## 何时不更新或创建文档

跳过以下内容的文档更新/创建：
- 错误修复（除非它们改变架构）
- 次要调整或清理
- 调试或临时变更
- 代码格式化或注释
- 琐碎的修改
- 适合现有文档范围的单文件添加

## 3 层系统优势

这种增强方法利用 3 层文档系统来：
- **最小化级联效应**：大多数变更更新 1-2 个细粒度文件
- **智能扩展**：仅在有必要时创建新文档
- **就近放置知识**：文档就在相关代码附近
- **保持一致性**：何时以及如何扩展文档的清晰指南

现在分析指定的变更并相应地更新相关文档。